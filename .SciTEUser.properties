# @prog         scite
# @lastProgVers 4.0.5
# @since        2015-12-23
# @lastChanged  2019-02-10
# @author       Mort Yao <soi@mort.ninja>

# Default encoding (UTF-8)
code.page=65001

# Default end-of-line (LF)
eol.mode=LF

# Prefered coding style (4-whitespace indentation)
indent.size=4
use.tabs=0

# Behaviors
load.on.activate=1
are.you.sure.on.reload=1
reload.preserves.undo=1

# Sessions
save.position=1
save.recent=1
save.session=1
session.bookmarks=1
session.folds=1

# UI tweaks
fold.symbols=2
line.margin.visible=1
magnification=1
pathbar.visible=0
wrap=1

# Status bar
statusbar.visible=1
statusbar.text.1=\
[$(Language)]  ($(LineNumber), $(ColumnNumber))  $(OverType)  <$(EOLMode)>  |  $(BufferLength) chars in $(NbOfLines) lines. $(SelLength) chars selected.  |  $(FilePath)  ($(FileDate) $(FileTime))

# Default fonts (Inconsolata)
font.base=font:Inconsolata,size:10
font.small=font:Inconsolata,size:9
font.comment=font:Inconsolata,size:10
font.text=font:Inconsolata,size:10
font.text.comment=font:Inconsolata,size:10
font.embedded.base=font:Inconsolata,size:10
font.embedded.comment=font:Inconsolata,size:10
font.monospace=font:Inconsolata,size:10
font.vbs=font:Inconsolata,size:10

# Default style (ivory)
style.*.32=$(font.base),back:#FFFFF0,fore:#000000

# Default caret style
caret.width=3
caret.line.back=#B0C4DE
caret.line.back.alpha=63

# Keyboard commands
user.shortcuts=\
Ctrl+Shift+PageUp|IDM_MOVETABLEFT|\
Ctrl+Shift+PageDown|IDM_MOVETABRIGHT|\
Alt+Left|IDM_MOVETABLEFT|\
Alt+Right|IDM_MOVETABRIGHT|\
Ctrl+T|IDM_NEW|\
Ctrl+E|2314|

# Load all .properties files
imports.exclude=

# Extra file patterns
file.patterns.bash=*.sh;*.bsh;configure;*.ksh\
;*.zsh;*.zshrc;*.zsh-theme\
;session
file.patterns.lisp=*.lsp;*.lisp\
;*.el
file.patterns.tex=*.elf

# Idris support
file.patterns.idr=*.idr
filter.idr=Idris (idr)|$(file.patterns.idr)|
lexer.*.idr=haskell
keywords.$(file.patterns.idr)=$(keywordclass.haskell98)

# F# support
file.patterns.fs=*.fs;*.fsi;*.fsscript;*.fsx
filter.fs=F# (fs fsi fsscript fsx)|$(file.patterns.fs)|
lexer.$(file.patterns.fs)=caml
keywordclass.fs=abstract and as assert base begin class default delegate do done downcast downto elif else end exception extern false finally for fun function global if in inherit inline interface internal lazy let let! match member module mutable namespace new not null of open or override private public rec return return! select static struct then to true try type upcast use use! val void when while with yield yield!
keywords.$(file.patterns.fs)=$(keywordclass.fs)

# MUR
file.patterns.mur=*.mur
filter.mur=MUR (mur)|$(file.patterns.mur)|
*filter.mur=$(filter.mur)
# We reuse the YAML lexer here
lexer.$(file.patterns.mur)=yaml
language.mur=MUR|mur||
